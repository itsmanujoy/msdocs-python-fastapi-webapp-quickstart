# import pandas as pd
# from typing import Dict, Any, Union, Optional, List, Tuple
# import json # For safer JSON parsing than eval
# import asyncio # For running async tools

# from langchain_core.messages import SystemMessage
# from langchain.agents import create_pandas_dataframe_agent, AgentExecutor, Tool
# from langchain.agents import AgentType
# from langchain.agents.output_parsers import OpenAIFunctionsAgentOutputParser
# from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
# from langchain.schema.runnable import RunnablePassthrough, RunnableLambda
# from langchain.schema.agent import AgentFinish
# from langchain_core.output_parsers import StrOutputParser

# # Correctly import services from your defined structure
# from services.llm_service import LLMService
# from services.document_qa import DocumentQAService
# from services.data_analyzer import DataAnalyzer
# from services.viz_generator import VizGenerator


# class InsightBotAgent:
#     def __init__(self, llm_service: LLMService, doc_qa_service: DocumentQAService, 
#                  data_analyzer: DataAnalyzer, viz_generator: VizGenerator):
#         self.llm_service = llm_service
#         self.doc_qa_service = doc_qa_service
#         self.data_analyzer = data_analyzer
#         self.viz_generator = viz_generator
#         self.current_dataframe: Optional[pd.DataFrame] = None
#         self.current_document_id: Optional[str] = None
#         self.df_schema_str: str = "" # Stores schema as a string for LLM context

#         # Define tools for the agent
#         self.tools = self._setup_tools()
#         self.agent_executor = self._create_main_agent()

#     def set_dataframe(self, df: pd.DataFrame):
#         """Sets the current DataFrame for data analysis tasks."""
#         self.current_dataframe = df
#         # Update schema for data analysis tools
#         self.df_schema_str = "\n".join([f"- {col}: {str(df[col].dtype)}" for col in df.columns])
#         # Re-create the agent executor if a new DF is set, to ensure tools context is fresh
#         self.agent_executor = self._create_main_agent()


#     def set_document_context(self, doc_id: str):
#         """Sets the ID of the document currently in context for QA."""
#         self.current_document_id = doc_id
#         # Re-create the agent executor if a new doc is set, to ensure tools context is fresh
#         self.agent_executor = self._create_main_agent()


#     def _setup_tools(self) -> List[Tool]:
#         """Defines the tools available to the agent."""
        
#         # Tool for executing pandas code (generated by LLM)
#         def run_pandas_code(code: str) -> str:
#             """
#             Executes a pandas code snippet on the currently loaded DataFrame.
#             Input: pandas code string.
#             Output: Result of the code execution as a markdown table or string, or an error message.
#             """
#             if self.current_dataframe is None:
#                 return "No dataframe loaded. Please upload a dataset first."
            
#             # Use the data_analyzer to execute the code
#             # We pass a copy to avoid accidental modification of the original dataframe by the agent
#             result, error_output = self.data_analyzer.execute_code_on_dataframe(self.current_dataframe.copy(), code)
            
#             if error_output and "Error executing code" in error_output:
#                 return f"Error executing code: {error_output}"
#             if result is not None:
#                 # Convert result to string for agent observation
#                 if isinstance(result, (pd.DataFrame, pd.Series)):
#                     # For DataFrames/Series, return a markdown table for readability
#                     return result.to_markdown(index=False) 
#                 return str(result)
#             return "Code executed successfully. No direct output returned from the last expression."

#         # Tool for getting metadata summary
#         def get_metadata() -> str:
#             """
#             Provides a comprehensive metadata summary of the currently loaded DataFrame,
#             including row/column counts, data types, missing values, and descriptive statistics.
#             """
#             if self.current_dataframe is None:
#                 return "No dataframe loaded."
#             metadata = self.data_analyzer.get_metadata_summary(self.current_dataframe)
#             return f"Metadata Summary:\n{json.dumps(metadata, indent=2)}"

#         # Tool for getting data quality report
#         def get_quality_report() -> str:
#             """
#             Generates a data quality report for the currently loaded DataFrame,
#             including checks for null values, duplicates, and outliers.
#             """
#             if self.current_dataframe is None:
#                 return "No dataframe loaded."
#             report = self.data_analyzer.run_data_quality_checks(self.current_dataframe)
#             return f"Data Quality Report:\n{json.dumps(report, indent=2)}"
        
#         # Tool for querying documents (async)
#         async def query_doc_async(query: str) -> str:
#             """
#             Queries the currently loaded document for specific information using Retrieval-Augmented Generation (RAG).
#             Input: The question to ask about the document.
#             Output: The answer extracted from the document or generated based on its content.
#             """
#             if self.current_document_id is None:
#                 return "No document loaded for QA. Please upload a document first."
#             return await self.doc_qa_service.query_document(query, self.current_document_id)

#         # Sync wrapper for async tool for Langchain Agent (if needed by agent type)
#         def query_doc_sync(query: str) -> str:
#              return asyncio.run(query_doc_async(query))

#         # Tool for generating static charts (matplotlib/seaborn)
#         def generate_plot(chart_params_json: str) -> str:
#             """
#             Generates a static chart (e.g., bar, line, scatter, hist, box) from the loaded DataFrame.
#             Input: A JSON string specifying 'chart_type' (e.g., 'bar', 'line'), 'x_col', 'y_col' (optional), and other kwargs.
#             Example: '{"chart_type": "bar", "x_col": "Region", "y_col": "Sales"}'
#             Output: A string indicating success and containing a base64 encoded PNG image tag, or an error message.
#             """
#             if self.current_dataframe is None:
#                 return "No dataframe loaded. Please upload a dataset first."
#             try:
#                 params = json.loads(chart_params_json) # Use json.loads for safer parsing
#                 chart_type = params.pop('chart_type')
#                 x_col = params.pop('x_col', None)
#                 y_col = params.pop('y_col', None)

#                 base64_img = self.viz_generator.generate_chart(self.current_dataframe, chart_type, x_col, y_col, **params)
#                 if base64_img:
#                     # The ` tag will be replaced by the image generation model
#                     return f"Generated image: 

#                                                 "]
#                         return "Failed to generate chart."
#                         except json.JSONDecodeError:
#                         return f"Error: Invalid JSON input for chart parameters: {chart_params_json}"
#                         except Exception as e:
#                         return f"Error parsing chart parameters or generating chart: {e}"


#     # Tool for generating interactive charts (Plotly JSON)
#     def generate_interactive_plot(chart_params_json: str) -> str:
#         """
#         Generates an interactive Plotly chart from the loaded DataFrame as a JSON object.
#         Input: A JSON string specifying 'chart_type' (e.g., 'bar', 'line'), 'x_col', 'y_col' (optional), and other kwargs.
#         Example: '{"chart_type": "bar", "x_col": "Category", "y_col": "Value", "color": "Region"}'
#         Output: A JSON string representing the Plotly figure, or an error message.
#         """
#         if self.current_dataframe is None:
#             return "No dataframe loaded. Please upload a dataset first."
#         try:
#             params = json.loads(chart_params_json)
#             chart_type = params.pop('chart_type')
#             x_col = params.pop('x_col', None)
#             y_col = params.pop('y_col', None)

#             plotly_json_fig = self.viz_generator.generate_plotly_chart(self.current_dataframe, chart_type, x_col, y_col, **params)
#             if plotly_json_fig:
#                 return f"Generated interactive Plotly chart (JSON): {plotly_json_fig}"
#             return "Failed to generate interactive chart."
#         except json.JSONDecodeError:
#             return f"Error: Invalid JSON input for interactive chart parameters: {chart_params_json}"
#         except Exception as e:
#             return f"Error parsing chart parameters or generating interactive chart: {e}"


#     return [
#         Tool(name="run_pandas_code", func=run_pandas_code,
#              description="Executes a pandas code snippet on the current dataframe to perform data analysis, filtering, grouping, or transformation. Input: Python pandas code."),
#         Tool(name="get_metadata_summary", func=get_metadata,
#              description="Provides a comprehensive metadata summary of the current dataframe, including column info, data types, and missing values."),
#         Tool(name="get_data_quality_report", func=get_quality_report,
#              description="Generates a data quality report for the current dataframe, checking for nulls, duplicates, and outliers."),
#         Tool(name="query_document", func=query_doc_sync, # Using the sync wrapper for the agent
#              description="Queries the loaded document using natural language to extract specific information or answers. Input: The question to ask about the document."),
#         Tool(name="generate_static_plot", func=generate_plot,
#              description="Generates a static image plot (e.g., bar, line, scatter, hist, box) from the dataframe. Input: JSON string with 'chart_type', 'x_col', 'y_col' (optional)."),
#         Tool(name="generate_interactive_plot", func=generate_interactive_plot,
#              description="Generates an interactive Plotly chart as a JSON object from the dataframe. Input: JSON string with 'chart_type', 'x_col', 'y_col' (optional).")
#     ]

# def _create_main_agent(self) -> AgentExecutor:
#     """
#     Creates and returns the Langchain agent executor.
#     Uses a custom prompt to guide the agent's decision-making.
#     """
#     # Define the system message for the agent
#     system_message_content = """
#     You are InsightBot, an advanced AI data and document analyzer.
#     You have access to a pandas DataFrame (named `df`) and potentially a document.
    
#     Your capabilities include:
#     1. Answering questions about the data by running pandas code.
#     2. Providing detailed metadata and data quality reports.
#     3. Answering questions by querying an uploaded document.
#     4. Generating various types of data visualizations (static images or interactive Plotly charts).

#     When interacting with data, consider the dataframe's schema:
#     {df_schema}

#     Carefully analyze the user's request and choose the most appropriate tool(s).
#     If the user asks for data analysis or specific numerical results, use `run_pandas_code`.
#     If the user asks for data overview, use `get_metadata_summary` or `get_data_quality_report`.
#     If the user asks a question about an uploaded document, use `query_document`.
#     If the user asks for a chart or visualization, use `generate_static_plot` or `generate_interactive_plot`.
    
#     Always strive to provide a clear, concise answer.
#     If you generate code, ensure it directly addresses the question.
#     If you provide a visualization, explain what it shows.
#     If you need more information (e.g., column names for a plot), ask the user.
#     """

#     prompt = ChatPromptTemplate.from_messages(
#         [
#             SystemMessage(content=system_message_content.format(df_schema=self.df_schema_str)),
#             MessagesPlaceholder(variable_name="chat_history", optional=True), # For conversation history
#             ("human", "{input}"),
#             MessagesPlaceholder(variable_name="agent_scratchpad"), # For agent's thought process
#         ]
#     )

#     # We'll use the LLMService to provide the underlying model
#     # Using the Groq LLM by default, or GenAI as a fallback
#     llm_model = self.llm_service.groq_llm if self.llm_service.groq_llm else self.llm_service.genai_llm
#     if not llm_model:
#         raise ValueError("No LLM is configured or available for the agent.")

#     # Create the agent
#     # For a complex tool-use agent, using 'openai-functions' agent type with a compatible LLM
#     # is often powerful. Groq models (like Llama3) can be finetuned for this.
#     # Alternatively, a custom agent or 'zero-shot-react-description' can be used.
#     # For simplicity, let's start with create_react_agent
#     from langchain.agents import create_react_agent
    
#     agent = create_react_agent(llm_model, self.tools, prompt)

#     # Create the AgentExecutor
#     agent_executor = AgentExecutor(agent=agent, tools=self.tools, verbose=True, handle_parsing_errors=True)
    
#     return agent_executor


# async def ainvoke_agent(self, user_query: str, chat_history: List[Dict[str, str]] = None) -> Dict[str, Any]:
#     """
#     Asynchronously invokes the InsightBot agent with a user query.
#     """
#     inputs = {"input": user_query, "chat_history": chat_history if chat_history else []}
    
#     try:
#         response = await self.agent_executor.ainvoke(inputs)
#         return {"answer": response.get("output", "I couldn't process that request."), "tool_thoughts": response}
#     except Exception as e:
#         print(f"Error invoking agent: {e}")
#         return {"answer": f"An internal error occurred: {e}", "tool_thoughts": {}}


import pandas as pd
from typing import Dict, Any, List, Optional
from langchain_core.messages import SystemMessage
from langchain.agents import Tool
from langchain_experimental.agents import create_pandas_dataframe_agent
from langchain.agents import  AgentExecutor
from langchain.agents import AgentType
from langchain_experimental.agents import create_pandas_dataframe_agent

from services.llm_service import LLMService
from services.document_qa import DocumentQAService
from services.data_analyzer import DataAnalyzer
from services.viz_generator import VizGenerator


class InsightBotAgent:
    def __init__(self, llm_service: LLMService, doc_qa_service: DocumentQAService,
                 data_analyzer: DataAnalyzer, viz_generator: VizGenerator):
        self.llm_service = llm_service
        self.doc_qa_service = doc_qa_service
        self.data_analyzer = data_analyzer
        self.viz_generator = viz_generator
        self.current_dataframe: Optional[pd.DataFrame] = None
        self.current_document_id: Optional[str] = None
        self.df_schema_str: str = ""

        # Define tools for the agent
        self.tools = self._setup_tools()
        self.agent_executor: Optional[AgentExecutor] = None
        try:
            self.agent_executor = self._create_main_agent()
        except Exception as e:
            # If LangChain agent creation fails (e.g., missing deps), keep None but allow tools to be used directly
            print(f"Warning: failed to create LangChain agent executor: {e}")

    def set_dataframe(self, df: pd.DataFrame):
        self.current_dataframe = df
        # Update schema for data analysis tools
        self.df_schema_str = "\n".join([f"- {col}: {str(df[col].dtype)}" for col in df.columns])

    def set_document_context(self, doc_id: str):
        self.current_document_id = doc_id

    def _setup_tools(self) -> List[Tool]:
        # Tool for executing pandas code (generated by LLM)
        def run_pandas_code(code: str) -> str:
            if self.current_dataframe is None:
                return "No dataframe loaded. Please upload a dataset first."

            # Use the data_analyzer to execute the code
            result, error = self.data_analyzer.execute_code_on_dataframe(self.current_dataframe.copy(), code)

            if error:
                return f"Error executing code: {error}"
            if result is not None:
                # Convert result to string for agent observation
                if isinstance(result, (pd.DataFrame, pd.Series)):
                    try:
                        return result.to_markdown(index=False)
                    except Exception:
                        return result.to_string()
                return str(result)
            return "Code executed successfully. No direct output returned from the last expression."

        # Tool for getting metadata summary
        def get_metadata(_: str = "") -> str:
            if self.current_dataframe is None:
                return "No dataframe loaded."
            metadata = self.data_analyzer.get_metadata_summary(self.current_dataframe)
            return f"Metadata Summary:\n{metadata}"

        # Tool for getting data quality report
        def get_quality_report(_: str = "") -> str:
            if self.current_dataframe is None:
                return "No dataframe loaded."
            report = self.data_analyzer.run_data_quality_checks(self.current_dataframe)
            return f"Data Quality Report:\n{report}"

        # Tool for querying documents (async wrapper not required for simple Tool definition)
        async def query_doc(query: str) -> str:
            if self.current_document_id is None:
                return "No document loaded for QA."
            return await self.doc_qa_service.query_document(query, self.current_document_id)

        # Tool for generating charts (static image)
        def generate_plot(chart_params_json: str) -> str:
            if self.current_dataframe is None:
                return "No dataframe loaded."
            try:
                # Safer parsing than eval would be ideal; for brevity we use literal_eval
                from ast import literal_eval
                params = literal_eval(chart_params_json)
                if not isinstance(params, dict):
                    return "chart_params_json must evaluate to a dict."

                chart_type = params.pop('chart_type', None)
                x_col = params.pop('x_col', None)
                y_col = params.pop('y_col', None)

                base64_img = self.viz_generator.generate_chart(self.current_dataframe, chart_type, x_col, y_col, **params)
                if base64_img:
                    # Return a data URI that frontends can render directly
                    return f"data:image/png;base64,{base64_img}"
                return "Failed to generate chart."
            except Exception as e:
                return f"Error generating plot: {e}"

        tools = [
            Tool(name="run_pandas_code", func=run_pandas_code, description="Execute pandas code on the current dataframe."),
            Tool(name="get_metadata", func=get_metadata, description="Get metadata summary of the current dataframe."),
            Tool(name="get_quality_report", func=get_quality_report, description="Run data quality checks."),
            Tool(name="query_document", func=query_doc, description="Query the loaded document using RAG."),
            Tool(name="generate_plot", func=generate_plot, description="Generate a chart from the current dataframe. Expects a dict with keys chart_type, x_col, y_col, etc., passed as a string literal.")
        ]

        return tools

    def _create_main_agent(self) -> AgentExecutor:
        """Create a LangChain agent that can use the tools above. This is optional and will
        fall back gracefully if LangChain isn't properly configured in the runtime."""
        # The create_pandas_dataframe_agent is a handy starting point; we provide a lightweight LLM
        # from our LLMService for the agent. If unavailable, this will raise and be caught in __init__.
        llm = None
        # prefer Groq, otherwise Gemeni
        if self.llm_service.groq_llm:
            llm = self.llm_service.groq_llm
        elif self.llm_service.genai_llm:
            llm = self.llm_service.genai_llm

        if llm is None:
            raise ValueError("No LLM available to create agent. Configure GROQ_API_KEY or GOOGLE_API_KEY.")

        # create a simple agent that can call tools
        agent = create_pandas_dataframe_agent(
            llm=llm,
            df=self.current_dataframe if self.current_dataframe is not None else pd.DataFrame(),
            verbose=False,
            agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
            return_intermediate_steps=False,
        )
        return agent

    async def handle_user_query(self, query: str) -> str:
        """Main entrypoint for processing user queries. The agent will attempt to use the LangChain
        agent if available; otherwise we fall back to a heuristic router that calls our tools directly."""
        # If we have a live agent_executor, let it handle the query
        if self.agent_executor is not None:
            try:
                # If df changed since agent creation, update agent's df (best-effort)
                if hasattr(self.agent_executor, 'tools'):
                    # Some LangChain versions embed df directly in the agent; recreate if necessary
                    pass
                response = await self.agent_executor.arun(query)
                return response
            except Exception as e:
                # Fall back to direct tool routing if agent run fails
                print(f"Agent run failed, falling back to tools: {e}")

        # Heuristic routing (simple): look for keywords
        q_lower = query.lower()
        if any(kw in q_lower for kw in ['plot', 'chart', 'visual', 'visualize']):
            # Ask the LLM to produce chart params, then call generate_plot
            system_msg = "You are an assistant that returns a Python dict (as a string) with keys: chart_type, x_col, y_col (optional), and any chart kwargs."
            prompt = f"Produce chart parameters for this request (as a Python dict): {query}\n\nDataFrame schema:\n{self.df_schema_str}"
            chart_params_str = await self.llm_service.get_response(prompt=prompt, system_message=system_msg, use_groq=True)
            # Try to call generate_plot tool
            for t in self.tools:
                if t.name == 'generate_plot':
                    return t.func(chart_params_str)

        if any(kw in q_lower for kw in ['missing', 'null', 'quality', 'outlier', 'duplicate']):
            for t in self.tools:
                if t.name == 'get_quality_report':
                    return t.func()

        if any(kw in q_lower for kw in ['schema', 'metadata', 'columns', 'dtypes']):
            for t in self.tools:
                if t.name == 'get_metadata':
                    return t.func()

        if any(kw in q_lower for kw in ['query document', 'document', 'doc', 'find in document', 'what does the document say']):
            # If user intends to query document, call query_document tool via LLM's short prompt
            # We assume the user query itself is the doc query
            for t in self.tools:
                if t.name == 'query_document':
                    # query_doc is async
                    return await t.func(query)

        # As a last resort, try to translate the user's natural language into pandas code using LLM
        try:
            code = await self.llm_service.generate_sql_query(query, {c: str(t) for c, t in (self.current_dataframe.dtypes.items() if self.current_dataframe is not None else {})})
            # Run the generated code
            for t in self.tools:
                if t.name == 'run_pandas_code':
                    return t.func(code)
        except Exception as e:
            print(f"Failed to generate/execute code: {e}")

        return "Sorry, I couldn't understand the request or perform the operation. Try rephrasing or provide a more specific instruction."
